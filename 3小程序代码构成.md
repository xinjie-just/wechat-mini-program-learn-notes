# 小程序代码构成

每个页面都包含 4 个文件。

- .json 后缀的 `JSON` 配置文件
- .wxml 后缀的 `WXML` 模板文件，全称 `WeiXin Markup Language`
- .wxss 后缀的 `WXSS` 样式文件，全称 `WeiXin Style Sheets`
- .js 后缀的 `JS` 脚本逻辑文件

## 1. JSON 配置

`JSON` 是一种数据格式，并不是编程语言，在小程序中，JSON扮演的静态配置的角色。可以在项目的根目录有一个 `app.json` 和 `project.config.json`，此外在 pages/ 目录下还有一个 `page.json`。

`app.json` 是小程序配置，`project.config.json` 是微信开发者工具配置，`page.json` 是页面配置。

`JSON` 中不能有注释。只能包含五种符号：`""`，`,`，`{}`，`[]`，`：`，不能出现其他符号。只能是以下六种数据格式：

- 数字，包含浮点数和整数
- 字符串，需要包裹在双引号中
- Boolean 值，true 或 false
- 数组，需要包裹在方扩号（[]）中
- 对象，需要包裹在花括号（{}）中
- Null

出现其它数据格式，如 undefined 将会报错。

**在小程序运行之前就决定了小程序一些表现，需要注意的是小程序是无法在运行过程中去动态更新 JSON 配置文件从而发生对应的变化的。**

## 2. `WXML` 模板

`WXML` 和 HTML `非常相似，WXML` 由标签、属性等等构成。但是也有很多不一样的地方。WXML 要求标签必须是严格闭合的，没有闭合将会导致编译错误。

```wxml
<text>hello world

<!--
text 没有闭合，导致编译错误：
VM148:2 ./pages/wxml/index.wxml
 end tag missing, near text
> 1 | <text>hello world
    | ^
-->
```

### 2.1. 标签名称

小程序的 `WXML` 用的标签是 `view`, `button`, `text` 等等，这些标签就是小程序给开发者包装好的基本能力，我们还提供了地图、视频、音频等等组件能力。

### 2.2. 多了一些 wx:if 这样的属性以及 `{{ }}` 这样的表达式

在网页的一般开发流程中，我们通常会通过 JS 操作 DOM (对应 HTML 的描述产生的树)，以引起界面的一些变化响应用户的行为。MVVM 的开发模式（例如 React, Vue），提倡把渲染和逻辑分离。简单来说就是不要再让 JS 直接操控 DOM，JS 只需要管理状态即可，然后再通过一种模板语法来描述状态和界面结构的关系即可。小程序的框架也是用到了这个思路。

`WXML` 是这么写 :

```WXML
<text>{{msg}}</text>
```

JS 只需要管理状态即可:

```JS
this.setData({ msg: "Hello World" })
```

### 2.3. 逻辑语法

#### 2.3.1. 数据绑定

没有被定义的变量的或者是被设置为 `undefined` 的变量不会被同步到 `wxml` 中。

```wxml
<!--
此处为 JS 代码，.js 文件的 data 属性中定义的字段。
{
  var2: undefined,
  var3: null,
  var4: "var4"
}
-->

<view>{{var1}}</view>
<view>{{var2}}</view>
<view>{{var3}}</view>
<view>{{var4}}</view>

<!--
输出：
null
var4
-->
```

#### 2.3.2. 条件逻辑

因为 `wx:if` 是一个控制属性，需要将它添加到一个标签上。如果要一次性判断多个组件标签，可以使用一个 `<block/>` 标签将多个组件包装起来，并在上边使用 `wx:if` 控制属性。

```wxml
<block wx:if="{{true}}">
  <view> view1 </view>
  <view> view2 </view>
</block>
```

#### 2.3.3. 列表渲染

在组件上使用 `wx:for` 控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。默认数组的当前项的下标变量名默认为 `index`，数组当前项的变量名默认为 `item`。使用 `wx:for-item` 指定数组当前元素的变量名，使用 `wx:for-index` 指定数组当前下标的变量名。

如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如 `<input/>` 中的输入内容， `<switch/>` 的选中状态），需要使用 `wx:key` 来指定列表中项目的唯一的标识符。

### 2.4. 共同属性

| 属性名         | 类型          | 描述           | 注释                                  |
| ------------- |-------------- | -------------- | ------------------------------------ |
| id            | String        | 组件的唯一标识  | 整个页面唯一                           |
| class         | String        | 组件的样式类    | 在对应的 WXSS 中定义的样式类            |
| style         | String        | 组件的内联样式  | 可以动态设置的内联样式                  |
| hidden        | Boolean       | 组件是否显示    |  所有组件默认显示                      |
| data-*        | Any           | 自定义属性      | 组件上触发的事件时，会发送给事件处理函数 |
| bind*/catch*  | EventHandler  | 组件的事件      |                                      |

## 3. `WXSS` 样式

`WXSS` 具有 `CSS` 大部分的特性，小程序在 `WXSS` 也做了一些扩充和修改。

项目公共样式：根目录中的 `app.wxss` 为项目公共样式，它会被注入到小程序的每个页面。页面样式：与 `app.json` 注册过的页面同名且位置同级的 `WXSS` 文件。其它样式：其它样式可以被项目公共样式和页面样式引用。

### 3.1. 尺寸单位

新增了尺寸单位。在写 CSS 样式时，开发者需要考虑到手机设备的屏幕会有不同的宽度和设备像素比，采用一些技巧来换算一些像素单位。`WXSS` 在底层支持新的尺寸单位 `rpx` ，开发者可以免去换算的烦恼，只要交给小程序底层来换算即可，由于换算采用的浮点数运算，所以运算结果会和预期结果有一点点偏差。

小程序编译后，`rpx` 会做一次 `px` 换算。换算是以 375 个物理像素为基准，也就是在一个宽度为 375 物理像素的屏幕下，1rpx = 1px。iPhone6 屏幕宽度为 375px，共 750 个物理像素，那么 1rpx = 375 / 750 px = 0.5px。

| 设备          | rpx 换算 px（屏幕宽度 / 750） | px 换算 rpx（750 / 屏幕宽度）|
| ------------- |---------------------------- | --------------------------- |
| iPhone5       | 1rpx = 320 / 750 = 0.42px   | 1px = 750 / 320 = 2.34rpx   |
| iPhone6       | 1rpx = 375 / 750 = 0.5px    | 1px = 750 / 375 = 2rpx      |
| iPhone6 Plus  | 1rpx = 414 / 750 = 0.552px  | 1px = 750 / 414 = 1.81rpx   |

### 3.2. WXSS 引用

在 CSS 中，开发者可以这样引用另一个样式文件：`@import url('./test_0.css')`。这种方法在请求上不会把 `test_0.css` 合并到 `index.css` 中，也就是请求 `index.css` 的时候，会多一个 `test_0.css` 的请求。

在小程序中，我们依然可以实现样式的引用，样式引用是这样写：`@import './test_0.wxss'`。由于 `WXSS` 最终会被编译打包到目标文件中，用户只需要下载一次，在使用过程中不会因为样式的引用而产生多余的文件请求。

### 3.3 选择器

| 类型         | 选择器       | 样例          | 样例描述                                     |
| ------------ | ----------- | ------------- | ------------------------------------------- |
| 类选择器     | .class       | .intro        | 选择所有拥有 class="intro" 的组件             |
| id选择器     | #id          | #firstName    | 选择拥有 id="firstName" 的组件               |
| 元素选择器   | element      | view checkbox | 选择所有文档的 view 组件和所有的 checkbox 组件 |
| 伪元素选择器 | ::after      | view::after   | 在 view 组件后边插入内容                      |
| 伪元素选择器 | ::before     | view::before  | 在 view 组件前边插入内容                      |

`WXSS` 优先级与 CSS 类似，权重是：

![WXSS 权重](./images/WXSS%E6%9D%83%E9%87%8D.png)

权重越高越优先。在优先级相同的情况下，后设置的样式优先级高于先设置的样式。

## 4. JS 交互逻辑

响应用户的操作使用 JS 来完成。还可以在 JS 中调用小程序提供的丰富的 API，利用这些 API 可以很方便的调起微信提供的能力，例如获取用户信息、本地存储、微信支付等。

- 浏览器中的 JavaScript：ECMAScript + DOM（文档对象模型） + BOM（浏览器对象模型）
- NodeJS 中的 JavaScript：ECMAScript + NPM + Native（原生模块，如 HTTP、FS、OS）
- NodeJS 中的 JavaScript：ECMAScript + 小程序框架 + 小程序 API

### 4.1. 小程序执行环境

目前小程序可以运行在三个平台:

- iOS 平台
- Android 平台
- 小程序 IDE

小程序 IDE 提供语法转码工具帮助开发者，将 `ECMAScript 6` 代码转为 `ECMAScript 5` 代码，从而在所有的环境都能得到很好的执行。

### 4.2. 模块化

小程序中可以将任何一个 JavaScript 文件作为一个模块，通过 `module.exports` 对外暴露接口，其它模块通过 `require` 引用。或者通过 `export` 对外暴露，通过 `import` 引用。

### 4.3. 脚本执行顺序

小程序的执行的入口文件是 app.js 。并且会根据其中 require 的模块顺序决定文件的运行顺序。当 app.js 执行结束后，小程序会按照开发者在 app.json 中定义的 pages 的顺序，逐一执行。

### 4.4. 作用域

在文件中声明的变量和函数只在该文件中有效，不同的文件中可以声明相同名字的变量和函数，不会互相影响。当需要使用全局变量的时，通过使用全局函数 getApp() 获取全局的实例，并设置相关属性值，来达到设置全局变量的目的。

定义全局变量：

```javascript
// app.js
App({
  globalData: 1
})
```

访问全局变量

```javascript
// a.js
// 获取全局变量
const global = getApp();
console.log(global) // 1
```
